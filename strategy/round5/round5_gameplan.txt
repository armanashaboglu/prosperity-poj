ROUND 5 ANALYSIS RESULTS:

RESIN:

Same strategy as in strategy/round3/round3_submission.py

KELP:

Same strategy as in strategy/round3/round3_submission.py

SQUID INK:

Same strategy as in strategy/round3/round3_submission.py, but we will optimize the parameters using all
of the days.

CROISSANTS:

If Caeser buys from Olivia, we go full SHORT.
If Olivia buys from Caeser, we go full LONG.

BASKETS and Components (Except for CROISSANTS):

We will use this strategy for all of the baskets and components except for CROISSANTS.
We will optimize long and short thresholds for each basket and component.

class SignalStrategy(Strategy):
    def __init__(self, symbol: Symbol, limit: int) -> None:
        super().__init__(symbol, limit)

        self.signal = Signal.NEUTRAL

    @abstractmethod
    def get_signal(self, state: TradingState) -> Signal | None:
        raise NotImplementedError()

    def act(self, state: TradingState) -> None:
        new_signal = self.get_signal(state)
        if new_signal is not None:
            self.signal = new_signal

        position = state.position.get(self.symbol, 0)
        order_depth = state.order_depths[self.symbol]

        if self.signal == Signal.NEUTRAL:
            if position < 0:
                self.buy(self.get_buy_price(order_depth), -position)
            elif position > 0:
                self.sell(self.get_sell_price(order_depth), position)
        elif self.signal == Signal.SHORT:
            self.sell(self.get_sell_price(order_depth), self.limit + position)
        elif self.signal == Signal.LONG:
            self.buy(self.get_buy_price(order_depth), self.limit - position)

    def get_buy_price(self, order_depth: OrderDepth) -> int:
        return min(order_depth.sell_orders.keys())

    def get_sell_price(self, order_depth: OrderDepth) -> int:
        return max(order_depth.buy_orders.keys())

    def save(self) -> JSON:
        return self.signal.value

    def load(self, data: JSON) -> None:
        self.signal = Signal(data)

class PicnicBasketStrategy(SignalStrategy):
    def get_signal(self, state: TradingState) -> Signal | None:
        if any(symbol not in state.order_depths for symbol in ["CHOCOLATE", "STRAWBERRIES", "ROSES", "GIFT_BASKET"]):
            return

        croissant = self.get_mid_price(state, "CROISSANTS")
        jams = self.get_mid_price(state, "JAMS")
        djembes = self.get_mid_price(state, "DJEMBES")
        picnic_basket1 = self.get_mid_price(state, "PICNIC_BASKET_1")
        picnic_basket2 = self.get_mid_price(state, "PICNIC_BASKET_2")

        diff = (picnic_basket1 - picnic_basket2) - (2*croissant + jams + djembes)

        long_threshold, short_threshold = {
            "CROISSANTS": (230, 355),
            "JAMS": (195, 485),
            "DJEMBES": (325, 370),
            "PICNIC_BASKET_1": (290, 355),
            "PICNIC_BASKET_2": (290, 355),
        }[self.symbol]

        if diff < long_threshold:
            return Signal.LONG
        elif diff > short_threshold:
            return Signal.SHORT

VOLCANIC ROCKS:

Same strategy as in strategy/round3/round3_submission.py
We will optimize the parameters.

VOUCHERS:
We will optimize the parameters of the strategy in strategy/round3/round3_submission.py to
see if we are able to get positive profits consistently. If not, dont trade.

MACARONS:

Dont trade.






